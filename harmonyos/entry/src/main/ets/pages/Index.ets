// 2048æ¸¸æˆ - é¸¿è’™ç‰ˆ
import promptAction from '@ohos.promptAction';
import vibrator from '@ohos.vibrator';

@Entry
@Component
struct Index {
  @State grid: number[][] = [];
  @State score: number = 0;
  @State bestScore: number = 0;
  @State gameOver: boolean = false;
  @State won: boolean = false;
  private gridSize: number = 4;
  private cellSize: number = 80;
  private cellGap: number = 10;
  
  aboutToAppear() {
    // ä»æœ¬åœ°å­˜å‚¨åŠ è½½æœ€é«˜åˆ†
    const stored = AppStorage.Get('bestScore');
    if (stored) {
      this.bestScore = stored as number;
    }
    this.initGame();
  }
  
  // åˆå§‹åŒ–æ¸¸æˆ
  initGame() {
    this.grid = Array(this.gridSize).fill(0).map(() => Array(this.gridSize).fill(0));
    this.score = 0;
    this.gameOver = false;
    this.won = false;
    this.addRandomTile();
    this.addRandomTile();
  }
  
  // æ·»åŠ éšæœºæ–¹å—
  addRandomTile() {
    const emptyCells: {row: number, col: number}[] = [];
    
    for (let i = 0; i < this.gridSize; i++) {
      for (let j = 0; j < this.gridSize; j++) {
        if (this.grid[i][j] === 0) {
          emptyCells.push({row: i, col: j});
        }
      }
    }
    
    if (emptyCells.length > 0) {
      const randomCell = emptyCells[Math.floor(Math.random() * emptyCells.length)];
      const value = Math.random() < 0.9 ? 2 : 4;
      this.grid[randomCell.row][randomCell.col] = value;
    }
  }
  
  // è·å–æ–¹å—é¢œè‰²
  getTileColor(value: number): string {
    const colors: Record<number, string> = {
      0: '#cdc1b4',
      2: '#eee4da',
      4: '#ede0c8',
      8: '#f2b179',
      16: '#f59563',
      32: '#f67c5f',
      64: '#f65e3b',
      128: '#edcf72',
      256: '#edcc61',
      512: '#edc850',
      1024: '#edc53f',
      2048: '#edc22e'
    };
    return colors[value] || '#3c3a32';
  }
  
  // è·å–æ–‡å­—é¢œè‰²
  getTextColor(value: number): string {
    return value <= 4 ? '#776e65' : '#f9f6f2';
  }
  
  // ç§»åŠ¨é€»è¾‘
  move(direction: 'up' | 'down' | 'left' | 'right'): boolean {
    const oldGrid = JSON.stringify(this.grid);
    let moved = false;
    
    // è½¬æ¢ç½‘æ ¼æ–¹å‘
    const rotated = this.rotateGrid(direction);
    
    // å‘å·¦ç§»åŠ¨å¹¶åˆå¹¶
    for (let i = 0; i < this.gridSize; i++) {
      const row = rotated[i].filter(cell => cell !== 0);
      const merged: number[] = [];
      
      for (let j = 0; j < row.length; j++) {
        if (j < row.length - 1 && row[j] === row[j + 1]) {
          merged.push(row[j] * 2);
          this.score += row[j] * 2;
          
          // æ£€æŸ¥æ˜¯å¦èµ¢å¾—æ¸¸æˆ
          if (row[j] * 2 === 2048 && !this.won) {
            this.won = true;
          }
          
          j++; // è·³è¿‡ä¸‹ä¸€ä¸ªå·²åˆå¹¶çš„æ–¹å—
        } else {
          merged.push(row[j]);
        }
      }
      
      // å¡«å……0
      while (merged.length < this.gridSize) {
        merged.push(0);
      }
      
      rotated[i] = merged;
    }
    
    // è½¬æ¢å›åŸæ–¹å‘
    this.grid = this.unrotateGrid(rotated, direction);
    
    moved = oldGrid !== JSON.stringify(this.grid);
    
    if (moved) {
      this.addRandomTile();
      this.updateBestScore();
      this.checkGameOver();
      
      // éœ‡åŠ¨åé¦ˆ
      vibrator.startVibration({
        type: 'time',
        duration: 50
      }, {
        id: 0,
        usage: 'touch'
      });
    }
    
    return moved;
  }
  
  // æ—‹è½¬ç½‘æ ¼ï¼ˆç”¨äºç»Ÿä¸€å¤„ç†å››ä¸ªæ–¹å‘ï¼‰
  rotateGrid(direction: string): number[][] {
    let result = this.grid.map(row => [...row]);
    
    switch (direction) {
      case 'up':
        result = this.transpose(result);
        break;
      case 'down':
        result = this.transpose(result).map(row => row.reverse());
        break;
      case 'right':
        result = result.map(row => row.reverse());
        break;
      case 'left':
      default:
        break;
    }
    
    return result;
  }
  
  // åæ—‹è½¬ç½‘æ ¼
  unrotateGrid(grid: number[][], direction: string): number[][] {
    let result = grid.map(row => [...row]);
    
    switch (direction) {
      case 'up':
        result = this.transpose(result);
        break;
      case 'down':
        result = result.map(row => row.reverse());
        result = this.transpose(result);
        break;
      case 'right':
        result = result.map(row => row.reverse());
        break;
      case 'left':
      default:
        break;
    }
    
    return result;
  }
  
  // è½¬ç½®çŸ©é˜µ
  transpose(matrix: number[][]): number[][] {
    return matrix[0].map((_, i) => matrix.map(row => row[i]));
  }
  
  // æ£€æŸ¥æ¸¸æˆæ˜¯å¦ç»“æŸ
  checkGameOver() {
    // æ£€æŸ¥æ˜¯å¦æœ‰ç©ºæ ¼
    for (let i = 0; i < this.gridSize; i++) {
      for (let j = 0; j < this.gridSize; j++) {
        if (this.grid[i][j] === 0) return;
      }
    }
    
    // æ£€æŸ¥æ˜¯å¦å¯ä»¥åˆå¹¶
    for (let i = 0; i < this.gridSize; i++) {
      for (let j = 0; j < this.gridSize; j++) {
        const current = this.grid[i][j];
        
        // æ£€æŸ¥å³ä¾§
        if (j < this.gridSize - 1 && current === this.grid[i][j + 1]) return;
        
        // æ£€æŸ¥ä¸‹æ–¹
        if (i < this.gridSize - 1 && current === this.grid[i + 1][j]) return;
      }
    }
    
    this.gameOver = true;
  }
  
  // æ›´æ–°æœ€é«˜åˆ†
  updateBestScore() {
    if (this.score > this.bestScore) {
      this.bestScore = this.score;
      AppStorage.SetOrCreate('bestScore', this.bestScore);
    }
  }
  
  // é‡æ–°å¼€å§‹
  restart() {
    this.initGame();
    promptAction.showToast({
      message: 'æ¸¸æˆé‡æ–°å¼€å§‹',
      duration: 1000
    });
  }
  
  build() {
    Column() {
      // æ ‡é¢˜æ 
      Row() {
        Text('2048')
          .fontSize(48)
          .fontWeight(FontWeight.Bold)
          .fontColor('#776e65')
        
        Blank()
        
        Column() {
          Text('æœ€é«˜åˆ†')
            .fontSize(14)
            .fontColor('#eee4da')
          Text(this.bestScore.toString())
            .fontSize(20)
            .fontWeight(FontWeight.Bold)
            .fontColor('#ffffff')
        }
        .width(100)
        .height(60)
        .backgroundColor('#bbada0')
        .borderRadius(8)
        .justifyContent(FlexAlign.Center)
        .margin({ right: 10 })
        
        Column() {
          Text('åˆ†æ•°')
            .fontSize(14)
            .fontColor('#eee4da')
          Text(this.score.toString())
            .fontSize(20)
            .fontWeight(FontWeight.Bold)
            .fontColor('#ffffff')
        }
        .width(100)
        .height(60)
        .backgroundColor('#bbada0')
        .borderRadius(8)
        .justifyContent(FlexAlign.Center)
      }
      .width('90%')
      .margin({ top: 20, bottom: 20 })
      
      // è¯´æ˜
      Row() {
        Text('ä½¿ç”¨æ»‘åŠ¨æ‰‹åŠ¿åˆå¹¶ç›¸åŒæ•°å­—!')
          .fontSize(14)
          .fontColor('#776e65')
        
        Blank()
        
        Button('æ–°æ¸¸æˆ')
          .fontSize(14)
          .fontWeight(FontWeight.Bold)
          .backgroundColor('#8f7a66')
          .fontColor('#f9f6f2')
          .borderRadius(6)
          .padding({ left: 15, right: 15, top: 8, bottom: 8 })
          .onClick(() => {
            this.restart();
          })
      }
      .width('90%')
      .margin({ bottom: 20 })
      
      // æ¸¸æˆç½‘æ ¼
      Stack() {
        // èƒŒæ™¯ç½‘æ ¼
        Column() {
          ForEach(Array.from({length: this.gridSize}), (_, i: number) => {
            Row() {
              ForEach(Array.from({length: this.gridSize}), (_, j: number) => {
                Column()
                  .width(this.cellSize)
                  .height(this.cellSize)
                  .backgroundColor('#cdc1b4')
                  .borderRadius(6)
                  .margin(this.cellGap / 2)
              })
            }
          })
        }
        .width(this.gridSize * (this.cellSize + this.cellGap))
        .height(this.gridSize * (this.cellSize + this.cellGap))
        .backgroundColor('#bbada0')
        .borderRadius(8)
        .padding(this.cellGap / 2)
        
        // æ–¹å—
        Column() {
          ForEach(Array.from({length: this.gridSize}), (_, i: number) => {
            Row() {
              ForEach(Array.from({length: this.gridSize}), (_, j: number) => {
                if (this.grid[i][j] !== 0) {
                  Column() {
                    Text(this.grid[i][j].toString())
                      .fontSize(this.grid[i][j] < 100 ? 32 : (this.grid[i][j] < 1000 ? 28 : 24))
                      .fontWeight(FontWeight.Bold)
                      .fontColor(this.getTextColor(this.grid[i][j]))
                  }
                  .width(this.cellSize)
                  .height(this.cellSize)
                  .backgroundColor(this.getTileColor(this.grid[i][j]))
                  .borderRadius(6)
                  .margin(this.cellGap / 2)
                  .justifyContent(FlexAlign.Center)
                  .transition({
                    type: TransitionType.Insert,
                    opacity: 0,
                    scale: { x: 0.8, y: 0.8 }
                  })
                  .animation({
                    duration: 200,
                    curve: Curve.EaseInOut
                  })
                } else {
                  Column()
                    .width(this.cellSize)
                    .height(this.cellSize)
                    .margin(this.cellGap / 2)
                }
              })
            }
          })
        }
        .width(this.gridSize * (this.cellSize + this.cellGap))
        .height(this.gridSize * (this.cellSize + this.cellGap))
        .padding(this.cellGap / 2)
        
        // æ¸¸æˆç»“æŸé®ç½©
        if (this.gameOver || this.won) {
          Column() {
            Text(this.won ? 'ä½ èµ¢äº†! ğŸ‰' : 'æ¸¸æˆç»“æŸ')
              .fontSize(36)
              .fontWeight(FontWeight.Bold)
              .fontColor('#ffffff')
              .margin({ bottom: 20 })
            
            Text(`æœ€ç»ˆåˆ†æ•°: ${this.score}`)
              .fontSize(20)
              .fontColor('#ffffff')
              .margin({ bottom: 30 })
            
            Button(this.won ? 'ç»§ç»­æŒ‘æˆ˜' : 'é‡æ–°å¼€å§‹')
              .fontSize(18)
              .fontWeight(FontWeight.Bold)
              .backgroundColor('#8f7a66')
              .fontColor('#f9f6f2')
              .borderRadius(8)
              .padding({ left: 30, right: 30, top: 12, bottom: 12 })
              .onClick(() => {
                if (this.won) {
                  this.won = false;
                } else {
                  this.restart();
                }
              })
          }
          .width('100%')
          .height('100%')
          .backgroundColor('rgba(238, 228, 218, 0.85)')
          .borderRadius(8)
          .justifyContent(FlexAlign.Center)
        }
      }
      .width(this.gridSize * (this.cellSize + this.cellGap))
      .height(this.gridSize * (this.cellSize + this.cellGap))
      .gesture(
        // æ»‘åŠ¨æ‰‹åŠ¿
        SwipeGesture({ direction: SwipeDirection.All })
          .onAction((event: GestureEvent) => {
            if (this.gameOver) return;
            
            const angle = event.angle;
            
            // æ ¹æ®è§’åº¦åˆ¤æ–­æ–¹å‘
            if (angle >= 45 && angle < 135) {
              // å‘ä¸‹
              this.move('down');
            } else if (angle >= 135 && angle < 225) {
              // å‘å·¦
              this.move('left');
            } else if (angle >= 225 && angle < 315) {
              // å‘ä¸Š
              this.move('up');
            } else {
              // å‘å³
              this.move('right');
            }
          })
      )
      
      // æç¤ºä¿¡æ¯
      Text('æ»‘åŠ¨æ–¹å‘é”®æ§åˆ¶ï¼Œåˆå¹¶ç›¸åŒæ•°å­—è¾¾åˆ°2048!')
        .fontSize(14)
        .fontColor('#776e65')
        .margin({ top: 30 })
        .textAlign(TextAlign.Center)
        .width('80%')
      
    }
    .width('100%')
    .height('100%')
    .backgroundColor('#faf8ef')
    .justifyContent(FlexAlign.Start)
  }
}
